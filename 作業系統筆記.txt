micro kernel微核心把kernel的功能與程式碼最小化，system service也在它之外，服務、應用之間的data交換必須通過kernel做IPC(inter-process communication)
monolithic kernel單核心把所有system service整合進kernel，並且裡面全都是privileged instructions
Deadlock意味著有兩個以上的processes或threads等運算單元都在等待彼此執行完成並釋出資源, 卻沒有人能先完成, 造成所有人停擺的現象
Deadlock的發生有四個條件:                                 
    -no preemption
    -hold and wait
    -mutual exclusion
    -circular waiting

PART ONE OVERVIEW
Chapter 1 Introduction

interrupt在現代OS中被廣泛用來處理非同步事件
電腦開機後跑的第一支程式是個bootstrap program，放在electrically erasable programmable read-only memory(EEPROM)
word是給定之電腦架構的自然資料單位，可能有一或更多個byte，電腦一次處理一個word而不是一個byte
1TB(terabyte)=1024^4 bytes, 1 PB(petabyte)=1024^5 bytes
電腦製造業會四捨五入的說1MB是一百萬bytes，1TB是十億bytes
networking測量比較例外，是以bit為單位，因為一次移動1 bit的資料
von Neumann architecture的系統下，一個典型的instruction-execution cycle會先fetch一個instruction進instruction register再fetch operands進來執行
blu-ray (藍光光碟)是以藍色雷射光束來進行讀寫作業，能儲存高品質、高容量的資料
secondary storage還有更下一層叫tertiary storage(第三儲存)，如optical disk, magnetic tapes等
NVM(nonvolatile memory)介於memory和hard-disk drive之間，常見的NVM device為flash memory，在行動裝置中很受歡迎
電子式NVS((nonvolatile storage)有flash memory, FRAM, NRAM, and SSD等
OS很大一部分code是貢獻在管理I/O這件事上
NVS I/O device透過DMA(direct memory access)跟memory傳送資料，而不需要CPU的intervention，它會設好buffers, pointers, counters，資料一次傳一整個block，然後才產生一個interrupt
一些高端系統使用switch架構而非bus架構，在這些系統上，多個components可以跟其他components對話concurrently，而不用在一個shared bus上競爭cycle
core是處理器中的component用來execute instructions和registers，single-processor(即單核單處理器) system其實包含很多special-purpose processors，如disk, keyboard, and graphics controllers等，它們都只run a limited instruction set 而不run processes，他們有些會受OS調度
最普遍的multiprocessor system使用symmetric multiprocessing(SMP)，each peer processor(core)執行所有任務包括OS functions跟user processes
multiprocessor的定義現在擴展到包含multicore systems，其中多個cores reside on a single chip，多核單處理器可以比單核多處理器更有效率，因為on-chip communication就是快
多核處理器中最靠近一個core的register的cache為L1 cache(較小、快並且是local的)，連接到L2(和L3) cache(較大、慢且是shared cache)
CPU一旦變多，system bus就變成效能bottleneck，所以另一種方法是所有CPU用shared system interconnect溝通，但他們有各自的local memory，此法名為NUMA(non-uniform memory access)，靠OS排程讓CPU們盡量只需用到自己的memory裡的東西，這種NUMA系統能容量大量處理器，在server跟高效能計算系統上很熱門
blade server是指一個系統包含多個processors, I/O, networking board套組，套組各自獨立且跑著自己的OS
clustered system由多個獨立的系統或nodes組成，每個node都是multicore system，此種系統是loosely coupled的，通常的定義是系統中的電腦會共用storage並由 a local-area network (LAN)或更快的interconnect像是InfiniBand連線
，它提供high-availability service，就算其中一個系統掛了也能繼續運作，nodes會互相監控，如果運作的機器掛了，監控他的node會用他的storage並在自己這個node重啟應用
對稱vs非對稱 clustering分別是 hosts都會跑app跟互相監控 vs 一個host跑app，另一個做hot-standby並監視他
parallelization是把一個program拆成數個部分在不同的core或電腦去跑
parallel clusters允許多個hosts使用共享的storage，那就要搭配distributed lock manager(DLM)去控制database的access跟locking
storage-area networks(SANs)允許眾多系統 attach to a pool of storage，那麼app的運作就不限定要哪個host，使用中的掛了就找其他host代替，大大提升效能跟可靠度
開機後kernel會提供system services，其中一些變成system daemons(常駐程式) e.g. Linux的第一支系統程式是"systemd"，它會啟動許多daemons
software產生的interrupts叫trap(or exception)，例如某些errors：除以零或非法的memory access
一個multiprogrammed system中，一支執行中的程式稱為process，最終process需要等待像是I/O等操作完成，在non-multiprogrammed system中CPU會idle而multiprogrammed system永遠不會idle而是暫時換到其他process來跑
multitasking是multiprogramming的擴展，意思是CPU跑多個processes以外，還切換得很頻繁，所以response time很短
CPU scheduling用來安排process的執行順序
multiprogramming and multitasking systems 必須提供file system、synchronization跟communication機制，還要確保processes不會發生deadlock
大部分電腦都有專用硬體來區分各種execution的mode，此硬體中的mode bit會指示當前任務的mode，0是kernel mode，1是user mode
最少會需要兩種mode的operation：user mode跟kernel mode(supervisor mode, system mode, or privileged mode)
當user application發出system call(trap的一種)來請求system service，系統會從user mode切換到kernel mode來做，做完後回到user process
如果試圖在user mode做privileged instruction，hardware不會執行而是traps it to the OS
privileged instructions舉例像是the instruction to switch to kernel mode, I/O control, timer management, and interrupt management等
Intel processors有四個protection rings，ring 0是kernel mode、ring 3是user mode、ring 1, ring 2是for各種OS services但很少用到
ARMv8系統有7個modes
支援virtualization的CPU常常有額外的一個mode來指出系統是不是在用virtual machine manager(VMM)，此mode權限大於user process少於kernel
system call這個trap通常可以用"trap"這instruction來實現，有些系統是叫 "syscall"
interrupt handler又叫interrupt service routine(ISR)，其pointer位於interrupt vector，vector中每個都是一個list
kernel根據system call的參數和額外資訊(在register, stack或memory中)來給予OS中對應的service
當program error產生，OS必須不正常地終止程序，這情況handled by the same code as 一個user-requested abnormal termination，error message產生並且程序的memory可能會被dump，back up(備份)進file
timer會週期性的發出interrupt，週期可以是固定也可以是可變(variable timer)，後者包含fixed-rate clock跟counter
process中有幾個threads就要有幾個program counters
a process is the unit of work in a system，processes can potentially execute concurrently-by multiplexing on a single CPU core-or in parallel across multiple CPU cores
講到process，OS負責(1)建立跟刪除user/system processes (2)CPU的process和threads排程 (3)processes的suspending跟resuming (4)提供process synchronization機制 (5)提供process communication機制
講到memory，OS負責(1)追蹤有在使用的memory以及被哪個process使用(2)分配跟釋放memory(3)決定哪個process(或process的部分)和data要move in and out of memory
一個file代表程式(包含source和object forms)和data之集合，data可以是numeric, alphabetic, alphanumeric, binary的，file可以是free form(e.g. text file)或formatted rigidly(fixed fields such as mp3等)
講到file，OS負責(1)增刪檔案(2)增刪目錄來組織檔案(3)支援用來操作檔案跟目錄的原語(primitive)(4)mapping files onto mass storage(5)備份檔案到non volatile 儲存media
講到mass-storage，OS負責次要存儲的(1)mounting and unmounting (2)free-space管理 (3)storage allocation (4)disk scheduling (5)partitioning (6)protection
register是種programable internal cache，register-allocation & register-replacement algorithm由compiler決定，cache的使用由hardware決定
cache coherency是說不同CPU的local cache改了變數的值，其餘的CPU的local cache要能立刻更新此值
OS的一個目的是對user hide the peculiarities(古怪) of 特定硬體裝置，例如在UNIX中，I/O devices的I/O subsystem能對OS隱藏自己，只有device driver知道這device的特別
I/O subsystem由下列組成 (1) 一個memory-management component 包含buffering, caching, and spooling (2) a general device-driver interface (3) derivers for specific hardware devices
